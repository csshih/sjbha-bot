// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var $$Promise = require("@ryyppy/rescript-promise/src/Promise.bs.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var FormatDistance = require("date-fns/formatDistance");

function done(prim) {
  
}

function identity(a) {
  return a;
}

function join(prim0, prim1) {
  return prim0.join(prim1);
}

var toList = Belt_List.fromArray;

var A = {
  get: Belt_Array.get,
  getExn: Belt_Array.getExn,
  set: Belt_Array.set,
  setExn: Belt_Array.setExn,
  shuffleInPlace: Belt_Array.shuffleInPlace,
  shuffle: Belt_Array.shuffle,
  reverseInPlace: Belt_Array.reverseInPlace,
  reverse: Belt_Array.reverse,
  make: Belt_Array.make,
  range: Belt_Array.range,
  rangeBy: Belt_Array.rangeBy,
  makeByU: Belt_Array.makeByU,
  makeBy: Belt_Array.makeBy,
  makeByAndShuffleU: Belt_Array.makeByAndShuffleU,
  makeByAndShuffle: Belt_Array.makeByAndShuffle,
  zip: Belt_Array.zip,
  zipByU: Belt_Array.zipByU,
  zipBy: Belt_Array.zipBy,
  unzip: Belt_Array.unzip,
  concat: Belt_Array.concat,
  concatMany: Belt_Array.concatMany,
  slice: Belt_Array.slice,
  sliceToEnd: Belt_Array.sliceToEnd,
  fill: Belt_Array.fill,
  blit: Belt_Array.blit,
  blitUnsafe: Belt_Array.blitUnsafe,
  forEachU: Belt_Array.forEachU,
  forEach: Belt_Array.forEach,
  mapU: Belt_Array.mapU,
  map: Belt_Array.map,
  getByU: Belt_Array.getByU,
  getBy: Belt_Array.getBy,
  getIndexByU: Belt_Array.getIndexByU,
  getIndexBy: Belt_Array.getIndexBy,
  keepU: Belt_Array.keepU,
  keep: Belt_Array.keep,
  keepWithIndexU: Belt_Array.keepWithIndexU,
  keepWithIndex: Belt_Array.keepWithIndex,
  keepMapU: Belt_Array.keepMapU,
  keepMap: Belt_Array.keepMap,
  forEachWithIndexU: Belt_Array.forEachWithIndexU,
  forEachWithIndex: Belt_Array.forEachWithIndex,
  mapWithIndexU: Belt_Array.mapWithIndexU,
  mapWithIndex: Belt_Array.mapWithIndex,
  partitionU: Belt_Array.partitionU,
  partition: Belt_Array.partition,
  reduceU: Belt_Array.reduceU,
  reduce: Belt_Array.reduce,
  reduceReverseU: Belt_Array.reduceReverseU,
  reduceReverse: Belt_Array.reduceReverse,
  reduceReverse2U: Belt_Array.reduceReverse2U,
  reduceReverse2: Belt_Array.reduceReverse2,
  reduceWithIndexU: Belt_Array.reduceWithIndexU,
  reduceWithIndex: Belt_Array.reduceWithIndex,
  joinWithU: Belt_Array.joinWithU,
  joinWith: Belt_Array.joinWith,
  someU: Belt_Array.someU,
  some: Belt_Array.some,
  everyU: Belt_Array.everyU,
  every: Belt_Array.every,
  every2U: Belt_Array.every2U,
  every2: Belt_Array.every2,
  some2U: Belt_Array.some2U,
  some2: Belt_Array.some2,
  cmpU: Belt_Array.cmpU,
  cmp: Belt_Array.cmp,
  eqU: Belt_Array.eqU,
  eq: Belt_Array.eq,
  join: join,
  toList: toList
};

function fromNow(t) {
  return FormatDistance(t, new Date(), {addSuffix: true});
}

var $$Date$1 = {
  fromNow: fromNow
};

var Dict = Js_dict;

function fromOption(option, err) {
  if (option !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(option)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: err
          };
  }
}

function mapAsync(result, fn) {
  if (result.TAG === /* Ok */0) {
    return Curry._1(fn, result._0).then(function (value) {
                return {
                        TAG: /* Ok */0,
                        _0: value
                      };
              });
  } else {
    return Promise.resolve(result);
  }
}

function flatMapAsync(result, fn) {
  if (result.TAG === /* Ok */0) {
    return Curry._1(fn, result._0);
  } else {
    return Promise.resolve(result);
  }
}

var R = {
  getExn: Belt_Result.getExn,
  mapWithDefaultU: Belt_Result.mapWithDefaultU,
  mapWithDefault: Belt_Result.mapWithDefault,
  mapU: Belt_Result.mapU,
  map: Belt_Result.map,
  flatMapU: Belt_Result.flatMapU,
  flatMap: Belt_Result.flatMap,
  getWithDefault: Belt_Result.getWithDefault,
  isOk: Belt_Result.isOk,
  isError: Belt_Result.isError,
  eqU: Belt_Result.eqU,
  eq: Belt_Result.eq,
  cmpU: Belt_Result.cmpU,
  cmp: Belt_Result.cmp,
  fromOption: fromOption,
  mapAsync: mapAsync,
  flatMapAsync: flatMapAsync
};

function resolve(prim) {
  return Promise.resolve(prim);
}

function map(prim0, prim1) {
  return prim0.then(Curry.__1(prim1));
}

function $$catch(t, f) {
  return $$Promise.$$catch(t, (function (exn) {
                return Promise.resolve(Curry._1(f, exn));
              }));
}

function flatMap(prim0, prim1) {
  return prim0.then(Curry.__1(prim1));
}

function run(promise, ok, $$catch) {
  $$Promise.$$catch(promise.then(Curry.__1(ok)), (function (exn) {
          return Promise.resolve(Curry._1($$catch, exn));
        }));
  
}

var P = {
  resolve: resolve,
  map: map,
  $$catch: $$catch,
  flatMap: flatMap,
  run: run
};

var L = Belt_List;

var O = Belt_Option;

var $$String = {};

exports.done = done;
exports.identity = identity;
exports.A = A;
exports.$$Date = $$Date$1;
exports.Dict = Dict;
exports.R = R;
exports.P = P;
exports.L = L;
exports.O = O;
exports.$$String = $$String;
/* date-fns/formatDistance Not a pure module */
