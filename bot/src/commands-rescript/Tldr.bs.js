// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Sjbha = require("../common/Sjbha.bs.js");
var StdLib = require("../common/StdLib.bs.js");
var Discord = require("../common/Discord.bs.js");
var MongoDb = require("../common/MongoDb.bs.js");
var DiscordJs = require("discord.js");
var SlashCommand = require("../common/SlashCommand.bs.js");
var CamlinternalLazy = require("rescript/lib/js/camlinternalLazy.js");

var collection = {
  LAZY_DONE: false,
  VAL: (function () {
      return MongoDb.getCollection("tldrs");
    })
};

function fetchRecent(count) {
  return StdLib.P.$$catch(StdLib.P.map(StdLib.P.flatMap(CamlinternalLazy.force(collection), (function (collection) {
                        return collection.find().sort({
                                        timestamp: -1
                                      }).limit(count).toArray();
                      })), (function (any) {
                    return {
                            TAG: /* Ok */0,
                            _0: any
                          };
                  })), (function (param) {
                return {
                        TAG: /* Error */1,
                        _0: "DATABASE_ERROR"
                      };
              }));
}

function insert(tldr) {
  return StdLib.P.$$catch(StdLib.P.map(StdLib.P.flatMap(CamlinternalLazy.force(collection), (function (__x) {
                        return __x.insertOne(tldr);
                      })), (function (param) {
                    return {
                            TAG: /* Ok */0,
                            _0: tldr
                          };
                  })), (function (param) {
                return {
                        TAG: /* Error */1,
                        _0: "DATABASE_ERROR"
                      };
              }));
}

var Tldrs = {
  collection: collection,
  fetchRecent: fetchRecent,
  insert: insert
};

function listRecentTldrs(interaction) {
  var tldrs = fetchRecent(10);
  return StdLib.P.map(tldrs, (function (tldrs) {
                if (tldrs.TAG !== /* Ok */0) {
                  if (tldrs._0 === "DATABASE_ERROR") {
                    return {
                            TAG: /* Error */2,
                            _0: "Problem loading tldrs from database"
                          };
                  } else {
                    return {
                            TAG: /* Error */2,
                            _0: "Something unexpected happened"
                          };
                  }
                }
                var embed = new DiscordJs.MessageEmbed().setTitle("ðŸ’¬ TLDR").setColor(11393254);
                Curry._2(StdLib.A.forEach, tldrs._0, (function (tldr) {
                        var value = "*" + StdLib.$$Date.fromNow(tldr.timestamp) + " â€¢ " + tldr.from + " â€¢ <#" + tldr.channelID + ">*";
                        Discord.Embed.addField(embed, tldr.message, value, /* Full */1);
                        
                      }));
                var privacy = interaction.channel.id === Sjbha.Channels.shitpost ? /* Public */0 : /* Private */1;
                return {
                        TAG: /* Embed */1,
                        _0: embed,
                        _1: privacy
                      };
              }));
}

function saveNewTldr(interaction) {
  var note = Discord.Interaction.getRequiredStringOption(interaction, "note");
  var savedTldr = StdLib.R.flatMapAsync(note, (function (note) {
          return insert({
                      message: note,
                      from: interaction.user.username,
                      timestamp: new Date(),
                      channelID: interaction.channel.id,
                      channel: interaction.channel.name
                    });
        }));
  return StdLib.P.map(savedTldr, (function (tldr) {
                if (tldr.TAG === /* Ok */0) {
                  var embed = new DiscordJs.MessageEmbed().setColor(11393254).setDescription("ðŸ“– " + tldr._0.message);
                  return {
                          TAG: /* Embed */1,
                          _0: embed,
                          _1: /* Public */0
                        };
                }
                var match = tldr._0;
                if (typeof match === "object") {
                  if (match.NAME === "MISSING_OPTION") {
                    return {
                            TAG: /* Error */2,
                            _0: "Missing required option " + match.VAL
                          };
                  } else {
                    return {
                            TAG: /* Error */2,
                            _0: "Unknown Reasons"
                          };
                  }
                } else if (match === "DATABASE_ERROR") {
                  return {
                          TAG: /* Error */2,
                          _0: "Unable to save TLDR"
                        };
                } else {
                  return {
                          TAG: /* Error */2,
                          _0: "Unknown Reasons"
                        };
                }
              }));
}

var partial_arg = true;

var partial_arg$1 = [(function (param) {
      return SlashCommand.stringOption("note", "What do you want to save?", partial_arg, undefined, param);
    })];

var command = SlashCommand.define(SlashCommand.make("tldr", "Summarize things that happen on discord", [
          (function (param) {
              return SlashCommand.subcommand("list", "Get a list of the most recent notes", undefined, undefined, param);
            }),
          (function (param) {
              return SlashCommand.subcommand("save", "Save a new note", partial_arg$1, undefined, param);
            })
        ], undefined), (function (interaction) {
        var subcommand = interaction.options.getSubcommand();
        var response;
        if (subcommand !== undefined) {
          switch (subcommand) {
            case "list" :
                response = listRecentTldrs(interaction);
                break;
            case "save" :
                response = saveNewTldr(interaction);
                break;
            default:
              response = StdLib.P.resolve({
                    TAG: /* Error */2,
                    _0: "Invalid Command"
                  });
          }
        } else {
          response = StdLib.P.resolve({
                TAG: /* Error */2,
                _0: "Invalid Command"
              });
        }
        return StdLib.P.run(response, (function (param) {
                      return Discord.Interaction.respond(interaction, param);
                    }), (function (param) {
                      return Discord.Interaction.error(interaction, param);
                    }));
      }));

var tldrs_count = 10;

var embed_color = 11393254;

exports.Tldrs = Tldrs;
exports.tldrs_count = tldrs_count;
exports.embed_color = embed_color;
exports.listRecentTldrs = listRecentTldrs;
exports.saveNewTldr = saveNewTldr;
exports.command = command;
/* command Not a pure module */
